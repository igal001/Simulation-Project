//
// Generated file, do not edit! Created by opp_msgc 4.1 from networklayer/RPL/DIOMessage.msg.
//

#ifndef _DIOMESSAGE_M_H_
#define _DIOMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0401
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "IPv6Address.h"
// }}



/**
 * Enum generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum DIO_TYPE{
 * 	Pad1 = 0;
 * 	PadN = 1;
 * 	Metric_Container = 2;
 * 	Routing_Information = 3;
 * 	DODAG_CONFIGURATION = 4;
 * 	Prefix_Information = 8;
 * }
 * </pre>
 */
enum DIO_TYPE {
    Pad1 = 0,
    PadN = 1,
    Metric_Container = 2,
    Routing_Information = 3,
    DODAG_CONFIGURATION = 4,
    Prefix_Information = 8
};

/**
 * Enum generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum DIO_LENGTH{
 *     DIO_HEADER = 24;
 *     PAD1_LENGTH = 1;
 * 	DODAG_CONFIGURATION_LENGTH = 14;
 * 	Prefix_Information_LENGTH = 30;
 * 	ETX_LENGTH = 6;
 * }
 * </pre>
 */
enum DIO_LENGTH {
    DIO_HEADER = 24,
    PAD1_LENGTH = 1,
    DODAG_CONFIGURATION_LENGTH = 14,
    Prefix_Information_LENGTH = 30,
    ETX_LENGTH = 6
};

/**
 * Enum generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum METRIC_TYPE{
 *     ETX_TYPE = 7;
 * }
 * </pre>
 */
enum METRIC_TYPE {
    ETX_TYPE = 7
};

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DIOheader{
 *    	uint8_t RPLInstance;		
 *     uint8_t VersionNumber;		
 *     uint16_t Rank;
 *     uint8_t GMP;						
 *     uint8_t DTSN;
 *     uint8_t Flags;
 *     uint8_t Reserved;
 *     IPv6Address DODAGID;				
 * }
 * </pre>
 */
class DIOheader : public ::cPacket
{
  protected:
    uint8_t RPLInstance_var;
    uint8_t VersionNumber_var;
    uint16_t Rank_var;
    uint8_t GMP_var;
    uint8_t DTSN_var;
    uint8_t Flags_var;
    uint8_t Reserved_var;
    ::IPv6Address DODAGID_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIOheader&);

  public:
    DIOheader(const char *name=NULL, int kind=0);
    DIOheader(const DIOheader& other);
    virtual ~DIOheader();
    DIOheader& operator=(const DIOheader& other);
    virtual DIOheader *dup() const {return new DIOheader(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getRPLInstance() const;
    virtual void setRPLInstance(uint8_t RPLInstance_var);
    virtual uint8_t getVersionNumber() const;
    virtual void setVersionNumber(uint8_t VersionNumber_var);
    virtual uint16_t getRank() const;
    virtual void setRank(uint16_t Rank_var);
    virtual uint8_t getGMP() const;
    virtual void setGMP(uint8_t GMP_var);
    virtual uint8_t getDTSN() const;
    virtual void setDTSN(uint8_t DTSN_var);
    virtual uint8_t getFlags() const;
    virtual void setFlags(uint8_t Flags_var);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t Reserved_var);
    virtual IPv6Address& getDODAGID();
    virtual const IPv6Address& getDODAGID() const {return const_cast<DIOheader*>(this)->getDODAGID();}
    virtual void setDODAGID(const IPv6Address& DODAGID_var);
};

inline void doPacking(cCommBuffer *b, DIOheader& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIOheader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DIOop{
 *     uint8_t Type enum(DIO_TYPE);
 * }
 * </pre>
 */
class DIOop : public ::cPacket
{
  protected:
    uint8_t Type_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIOop&);

  public:
    DIOop(const char *name=NULL, int kind=0);
    DIOop(const DIOop& other);
    virtual ~DIOop();
    DIOop& operator=(const DIOop& other);
    virtual DIOop *dup() const {return new DIOop(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getType() const;
    virtual void setType(uint8_t Type_var);
};

inline void doPacking(cCommBuffer *b, DIOop& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIOop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PAD1op extends DIOop{
 * }
 * </pre>
 */
class PAD1op : public ::DIOop
{
  protected:

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PAD1op&);

  public:
    PAD1op(const char *name=NULL, int kind=0);
    PAD1op(const PAD1op& other);
    virtual ~PAD1op();
    PAD1op& operator=(const PAD1op& other);
    virtual PAD1op *dup() const {return new PAD1op(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, PAD1op& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PAD1op& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PADNop extends DIOop{
 *     uint8_t Option_Length;
 * }
 * </pre>
 */
class PADNop : public ::DIOop
{
  protected:
    uint8_t Option_Length_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PADNop&);

  public:
    PADNop(const char *name=NULL, int kind=0);
    PADNop(const PADNop& other);
    virtual ~PADNop();
    PADNop& operator=(const PADNop& other);
    virtual PADNop *dup() const {return new PADNop(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getOption_Length() const;
    virtual void setOption_Length(uint8_t Option_Length_var);
};

inline void doPacking(cCommBuffer *b, PADNop& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PADNop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet METRIC_CONTop extends DIOop{
 *     uint8_t Option_Length;
 *     
 *     uint8_t RMCT enum(METRIC_TYPE);		
 *     uint8_t FPC0;						
 *     uint8_t RAP;						
 *     uint8_t Length;
 * }
 * </pre>
 */
class METRIC_CONTop : public ::DIOop
{
  protected:
    uint8_t Option_Length_var;
    uint8_t RMCT_var;
    uint8_t FPC0_var;
    uint8_t RAP_var;
    uint8_t Length_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const METRIC_CONTop&);

  public:
    METRIC_CONTop(const char *name=NULL, int kind=0);
    METRIC_CONTop(const METRIC_CONTop& other);
    virtual ~METRIC_CONTop();
    METRIC_CONTop& operator=(const METRIC_CONTop& other);
    virtual METRIC_CONTop *dup() const {return new METRIC_CONTop(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getOption_Length() const;
    virtual void setOption_Length(uint8_t Option_Length_var);
    virtual uint8_t getRMCT() const;
    virtual void setRMCT(uint8_t RMCT_var);
    virtual uint8_t getFPC0() const;
    virtual void setFPC0(uint8_t FPC0_var);
    virtual uint8_t getRAP() const;
    virtual void setRAP(uint8_t RAP_var);
    virtual uint8_t getLength() const;
    virtual void setLength(uint8_t Length_var);
};

inline void doPacking(cCommBuffer *b, METRIC_CONTop& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, METRIC_CONTop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ETX extends METRIC_CONTop{
 *     uint16_t ETX_VALUE;
 * }
 * </pre>
 */
class ETX : public ::METRIC_CONTop
{
  protected:
    uint16_t ETX_VALUE_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ETX&);

  public:
    ETX(const char *name=NULL, int kind=0);
    ETX(const ETX& other);
    virtual ~ETX();
    ETX& operator=(const ETX& other);
    virtual ETX *dup() const {return new ETX(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getETX_VALUE() const;
    virtual void setETX_VALUE(uint16_t ETX_VALUE_var);
};

inline void doPacking(cCommBuffer *b, ETX& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ETX& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ROUTING_INFOop extends DIOop{
 *     uint8_t Option_Length;
 *     uint8_t Prefix_Length;
 *     uint8_t RPR;						
 *     uint32_t Rout_Lifrtime;
 *     IPv6Address Prefix;
 * }
 * </pre>
 */
class ROUTING_INFOop : public ::DIOop
{
  protected:
    uint8_t Option_Length_var;
    uint8_t Prefix_Length_var;
    uint8_t RPR_var;
    uint32_t Rout_Lifrtime_var;
    ::IPv6Address Prefix_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ROUTING_INFOop&);

  public:
    ROUTING_INFOop(const char *name=NULL, int kind=0);
    ROUTING_INFOop(const ROUTING_INFOop& other);
    virtual ~ROUTING_INFOop();
    ROUTING_INFOop& operator=(const ROUTING_INFOop& other);
    virtual ROUTING_INFOop *dup() const {return new ROUTING_INFOop(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getOption_Length() const;
    virtual void setOption_Length(uint8_t Option_Length_var);
    virtual uint8_t getPrefix_Length() const;
    virtual void setPrefix_Length(uint8_t Prefix_Length_var);
    virtual uint8_t getRPR() const;
    virtual void setRPR(uint8_t RPR_var);
    virtual uint32_t getRout_Lifrtime() const;
    virtual void setRout_Lifrtime(uint32_t Rout_Lifrtime_var);
    virtual IPv6Address& getPrefix();
    virtual const IPv6Address& getPrefix() const {return const_cast<ROUTING_INFOop*>(this)->getPrefix();}
    virtual void setPrefix(const IPv6Address& Prefix_var);
};

inline void doPacking(cCommBuffer *b, ROUTING_INFOop& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ROUTING_INFOop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DODAG_CONFop extends DIOop{
 *     uint8_t Option_Length enum(DIO_LENGTH);
 *     uint8_t FAP;						
 *     uint8_t DIOIntDoubl;
 *     uint8_t DIOIntMin;
 *     uint8_t DIORedun;
 *     uint16_t MaxRankIncrease;
 *     uint16_t MinHopRankIncrease;
 *     uint16_t OCP;
 *     uint8_t Reserved;
 *     uint8_t Def_Lifetime;
 *     uint16_t Lifetime_Unit;
 * }
 * </pre>
 */
class DODAG_CONFop : public ::DIOop
{
  protected:
    uint8_t Option_Length_var;
    uint8_t FAP_var;
    uint8_t DIOIntDoubl_var;
    uint8_t DIOIntMin_var;
    uint8_t DIORedun_var;
    uint16_t MaxRankIncrease_var;
    uint16_t MinHopRankIncrease_var;
    uint16_t OCP_var;
    uint8_t Reserved_var;
    uint8_t Def_Lifetime_var;
    uint16_t Lifetime_Unit_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DODAG_CONFop&);

  public:
    DODAG_CONFop(const char *name=NULL, int kind=0);
    DODAG_CONFop(const DODAG_CONFop& other);
    virtual ~DODAG_CONFop();
    DODAG_CONFop& operator=(const DODAG_CONFop& other);
    virtual DODAG_CONFop *dup() const {return new DODAG_CONFop(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getOption_Length() const;
    virtual void setOption_Length(uint8_t Option_Length_var);
    virtual uint8_t getFAP() const;
    virtual void setFAP(uint8_t FAP_var);
    virtual uint8_t getDIOIntDoubl() const;
    virtual void setDIOIntDoubl(uint8_t DIOIntDoubl_var);
    virtual uint8_t getDIOIntMin() const;
    virtual void setDIOIntMin(uint8_t DIOIntMin_var);
    virtual uint8_t getDIORedun() const;
    virtual void setDIORedun(uint8_t DIORedun_var);
    virtual uint16_t getMaxRankIncrease() const;
    virtual void setMaxRankIncrease(uint16_t MaxRankIncrease_var);
    virtual uint16_t getMinHopRankIncrease() const;
    virtual void setMinHopRankIncrease(uint16_t MinHopRankIncrease_var);
    virtual uint16_t getOCP() const;
    virtual void setOCP(uint16_t OCP_var);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t Reserved_var);
    virtual uint8_t getDef_Lifetime() const;
    virtual void setDef_Lifetime(uint8_t Def_Lifetime_var);
    virtual uint16_t getLifetime_Unit() const;
    virtual void setLifetime_Unit(uint16_t Lifetime_Unit_var);
};

inline void doPacking(cCommBuffer *b, DODAG_CONFop& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DODAG_CONFop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet PREFIX_INFOop extends DIOop{
 *     uint8_t Option_Length enum(DIO_LENGTH);
 *     uint8_t Prefix_Length;
 *     uint8_t LARR;						
 *     uint32_t Valid_Lifetime;
 *     uint32_t Prf_Lifetime;
 *     uint32_t Reserved2;
 *     IPv6Address Prefix;
 * }
 * </pre>
 */
class PREFIX_INFOop : public ::DIOop
{
  protected:
    uint8_t Option_Length_var;
    uint8_t Prefix_Length_var;
    uint8_t LARR_var;
    uint32_t Valid_Lifetime_var;
    uint32_t Prf_Lifetime_var;
    uint32_t Reserved2_var;
    ::IPv6Address Prefix_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PREFIX_INFOop&);

  public:
    PREFIX_INFOop(const char *name=NULL, int kind=0);
    PREFIX_INFOop(const PREFIX_INFOop& other);
    virtual ~PREFIX_INFOop();
    PREFIX_INFOop& operator=(const PREFIX_INFOop& other);
    virtual PREFIX_INFOop *dup() const {return new PREFIX_INFOop(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getOption_Length() const;
    virtual void setOption_Length(uint8_t Option_Length_var);
    virtual uint8_t getPrefix_Length() const;
    virtual void setPrefix_Length(uint8_t Prefix_Length_var);
    virtual uint8_t getLARR() const;
    virtual void setLARR(uint8_t LARR_var);
    virtual uint32_t getValid_Lifetime() const;
    virtual void setValid_Lifetime(uint32_t Valid_Lifetime_var);
    virtual uint32_t getPrf_Lifetime() const;
    virtual void setPrf_Lifetime(uint32_t Prf_Lifetime_var);
    virtual uint32_t getReserved2() const;
    virtual void setReserved2(uint32_t Reserved2_var);
    virtual IPv6Address& getPrefix();
    virtual const IPv6Address& getPrefix() const {return const_cast<PREFIX_INFOop*>(this)->getPrefix();}
    virtual void setPrefix(const IPv6Address& Prefix_var);
};

inline void doPacking(cCommBuffer *b, PREFIX_INFOop& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PREFIX_INFOop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/RPL/DIOMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DIOMessage extends DIOheader {
 * 
 * }
 * </pre>
 */
class DIOMessage : public ::DIOheader
{
  protected:

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DIOMessage&);

  public:
    DIOMessage(const char *name=NULL, int kind=0);
    DIOMessage(const DIOMessage& other);
    virtual ~DIOMessage();
    DIOMessage& operator=(const DIOMessage& other);
    virtual DIOMessage *dup() const {return new DIOMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, DIOMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DIOMessage& obj) {obj.parsimUnpack(b);}


#endif // _DIOMESSAGE_M_H_
